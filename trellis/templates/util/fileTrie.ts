import { joinSegments } from "./path";

export class FileTrieNode {
  constructor(segments, data) {
    this.children = [];
    this.slugSegments = segments;
    this.data = data ?? null;
    this.isFolder = false;
    this.displayNameOverride = undefined;
  }

  get displayName() {
    const nonIndexTitle =
      this.data?.title === "index" ? undefined : this.data?.title;
    if (this.displayNameOverride) {
      return this.displayNameOverride;
    }
    if (nonIndexTitle) {
      return nonIndexTitle;
    }

    const fallback = this.fileSegmentHint ?? this.slugSegment ?? "";
    return fallback.replace(/-/g, " ");
  }

  set displayName(name) {
    this.displayNameOverride = name;
  }

  get slug() {
    const path = joinSegments(...this.slugSegments);
    if (this.isFolder) {
      return joinSegments(path, "index");
    }

    return path;
  }

  get slugSegment() {
    return this.slugSegments[this.slugSegments.length - 1];
  }

  makeChild(path, file) {
    const fullPath = [...this.slugSegments, path[0]];
    const child = new FileTrieNode(fullPath, file);
    this.children.push(child);
    return child;
  }

  insert(path, file) {
    if (path.length === 0) {
      throw new Error("path is empty");
    }

    // if we are inserting, we are a folder
    this.isFolder = true;
    const segment = path[0];
    if (path.length === 1) {
      // base case, we are at the end of the path
      if (segment === "index") {
        this.data ??= file;
      } else {
        this.makeChild(path, file);
      }
    } else if (path.length > 1) {
      // recursive case, we are not at the end of the path
      const child =
        this.children.find((c) => c.slugSegment === segment) ??
        this.makeChild(path, undefined);

      const fileParts = file.filePath.split("/");
      child.fileSegmentHint = fileParts.at(-path.length);
      child.insert(path.slice(1), file);
    }
  }

  // Add new file to trie
  add(file) {
    this.insert(file.slug.split("/"), file);
  }

  findNode(path) {
    if (path.length === 0 || (path.length === 1 && path[0] === "index")) {
      return this;
    }

    return this.children
      .find((c) => c.slugSegment === path[0])
      ?.findNode(path.slice(1));
  }

  ancestryChain(path) {
    if (path.length === 0 || (path.length === 1 && path[0] === "index")) {
      return [this];
    }

    const child = this.children.find((c) => c.slugSegment === path[0]);
    if (!child) {
      return undefined;
    }

    const childPath = child.ancestryChain(path.slice(1));
    if (!childPath) {
      return undefined;
    }

    return [this, ...childPath];
  }

  /**
   * Filter trie nodes. Behaves similar to `Array.prototype.filter()`, but modifies tree in place
   */
  filter(filterFn) {
    this.children = this.children.filter(filterFn);
    this.children.forEach((child) => child.filter(filterFn));
  }

  /**
   * Map over trie nodes. Behaves similar to `Array.prototype.map()`, but modifies tree in place
   */
  map(mapFn) {
    mapFn(this);
    this.children.forEach((child) => child.map(mapFn));
  }

  /**
   * Sort trie nodes according to sort/compare function
   */
  sort(sortFn) {
    this.children = this.children.sort(sortFn);
    this.children.forEach((e) => e.sort(sortFn));
  }

  static fromEntries(entries) {
    const trie = new FileTrieNode([]);
    entries.forEach(([, entry]) => trie.add(entry));
    return trie;
  }

  /**
   * Get all entries in the trie
   * in the a flat array including the full path and the node
   */
  entries() {
    const traverse = (node) => {
      const result = [[node.slug, node]];
      return result.concat(...node.children.map(traverse));
    };

    return traverse(this);
  }

  /**
   * Get all folder paths in the trie
   * @returns array containing folder state for trie
   */
  getFolderPaths() {
    return this.entries()
      .filter(([_, node]) => node.isFolder)
      .map(([path, _]) => path);
  }
}
